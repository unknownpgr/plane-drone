#!/usr/bin/env python3

import os
import sys
from select import select

# HW layer


def list_serial_ports():
    """
    Lists serial ports.

    device name is in the form of /dev/ttyUSBx or /dev/ttyACMx (linux)
    device name is in the form of /dev/cu.usb*
    """

    devices = os.listdir("/dev")
    serial_ports = []

    for device in devices:
        if (
            device.startswith("ttyUSB")
            or device.startswith("ttyACM")
            or device.startswith("cu.usb")
        ):
            serial_ports.append(f"/dev/{device}")

    return serial_ports


def set_baud_rate(serial_port, baud_rate):
    """
    Sets the baud rate of the serial port.
    """
    os.system(f"stty -f {serial_port} {baud_rate}")


def serial_write(fd: int, data: bytes):
    # Check input data length
    if len(data) > 31:
        print("Data too long. Max length is 31 bytes.")
        return

    # Add padding
    if len(data) < 31:
        data += b"\x00" * (31 - len(data))
    assert len(data) == 31

    # Calculate checksum
    checksum = 0
    for byte in data:
        checksum ^= byte
    checksum = bytes([checksum])

    magic_bytes = b"\x55\xAA"
    data = magic_bytes + data + checksum
    os.write(fd, data)


# Service layer


def read_state(fd: int):
    """
    Reads the state of the controller.
    """
    command_byte = 0x01
    timestamp_bytes = (0).to_bytes(4, byteorder="little")
    data = bytes([command_byte]) + timestamp_bytes
    serial_write(fd, data)


def set_throttle(fd: int, throttle: float):
    """
    Sets the throttle.

    available throttle range: 0.0 to 1.0
    """

    """
    1. limit throttle to 0.0 ~ 1.0
    2. map throttle from 0.0~1.0 to 0 ~ 2^16-1
    3. convert throttle to 2 bytes
    4. write to serial port
    """

    command_byte = 0x02
    throttle = int(throttle * 2**16)
    if throttle >= 2**16:
        throttle = 2**16 - 1
    if throttle < 0:
        throttle = 0
    throttle_bytes = throttle.to_bytes(2, byteorder="little")
    data = bytes([command_byte]) + throttle_bytes
    serial_write(fd, data)


def set_pitch(fd: int, pitch: float):
    """
    Sets the pitch.

    available pitch range: -90.0 to 90.0
    """

    """
    1. limit pitch to -90.0 ~ 90.0
    2. map pitch from -90.0~90.0 to 0 ~ 2^16-1
    3. convert pitch to 2 bytes
    4. write to serial port
    """

    command_byte = 0x03
    pitch = int((pitch + 90) / 180 * 2**16)
    if pitch >= 2**16:
        pitch = 2**16 - 1
    if pitch < 0:
        pitch = 0
    print(pitch)
    pitch_bytes = pitch.to_bytes(2, byteorder="little")
    data = bytes([command_byte]) + pitch_bytes
    serial_write(fd, data)


# CLI layer


def select_port():
    """
    Selects a serial port.
    """
    serial_ports = list_serial_ports()
    if not serial_ports:
        print("No serial ports found.")
        return None

    if len(serial_ports) == 1:
        print(f"Automatically selected serial port: {serial_ports[0]}")
        return serial_ports[0]

    while True:
        print("Select a serial port:")
        for i, port in enumerate(serial_ports):
            print(f"{i}: {port}")

        try:
            selection = int(input("Enter the port number: "))
            if selection < 0 or selection >= len(serial_ports):
                raise ValueError
        except ValueError:
            print("Invalid selection.")
            continue
        except KeyboardInterrupt:
            return None

        return serial_ports[selection]


def run_command(fd_serial, line):
    parts = line.split(" ")
    command = parts[0]
    args = parts[1:]

    if command == "state":
        if len(args) != 0:
            print("Usage: state")
            return
        read_state(fd_serial)

    elif command == "throttle":
        if len(args) != 1:
            print("Usage: throttle <throttle>")
            return
        try:
            throttle = float(args[0])
        except ValueError:
            print("Invalid throttle value.")
            return
        set_throttle(fd_serial, throttle)

    elif command == "pitch":
        if len(args) != 1:
            print("Usage: pitch <pitch>")
            return
        try:
            pitch = float(args[0])
        except ValueError:
            print("Invalid pitch value.")
            return
        set_pitch(fd_serial, pitch)

    elif command == "clear":
        os.system("clear")
    else:
        print("Unknown command.")


# Controller Layer


def main():
    serial_port = select_port()
    if not serial_port:
        print("No serial port selected. Aborting.")
        return

    set_baud_rate(serial_port, 9600)

    input_buffer = ""
    is_input_enabled = False

    # Disable input echo, buffer input
    os.system("stty -echo -icanon")

    fd_serial = os.open(serial_port, os.O_RDWR | os.O_NOCTTY)
    fd_stdin = sys.stdin.fileno()

    while True:
        try:
            read_list, _, _ = select([fd_serial, fd_stdin], [], [])
        except KeyboardInterrupt:
            break

        if fd_stdin in read_list:
            data = os.read(fd_stdin, 1)
            if is_input_enabled:
                os.write(sys.stdout.fileno(), data)

                # Backspace
                if data == b"\x7f":
                    input_buffer = input_buffer[:-1]
                    os.write(sys.stdout.fileno(), b"\b \b")
                else:
                    input_buffer += data.decode("utf-8")

                if data == b"\n":
                    line = input_buffer.strip()
                    input_buffer = ""
                    try:
                        run_command(fd_serial, line)
                    except Exception as e:
                        print(f"Error: {e}")

        if fd_serial in read_list:
            data = os.read(fd_serial, 1)
            if data == b"\x80":
                is_input_enabled = True
            else:
                os.write(sys.stdout.fileno(), data)

    os.close(fd_serial)
    print("\nExiting.")


if __name__ == "__main__":
    main()
